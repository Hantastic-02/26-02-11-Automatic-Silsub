#include "hal_data.h"
#include "g_hardware.h"
#include <stdio.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/** ADC **/
uint8_t pot_scaled = 0;
uint8_t cds_brightness = 0;

/** CAN **/
uint8_t can_data[8];
uint32_t can_id = 0;

/** ETH **/
uint32_t total_len = 0;
uint8_t payload_len = 0;
uint16_t pot;
uint16_t cds;
/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    HW_Setting();
    Hardware_Init();

    /* 링크 연결 대기 */
    while(g_ether_link_up == false)
    {
        R_ETHER_LinkProcess(&g_ether0_ctrl);
        R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
    }

    while(1) {
        ADC_Read_and_Convert();
        pot = potentiometer_mV;
        cds = cds_data;

        uint32_t duty_percent = (pot * 101) / 3300;
        if(duty_percent > 100) duty_percent = 100;
        R_GPT_DutyCycleSet(&g_timer3_ctrl, Timer_Period * duty_percent / 100, GPT_IO_PIN_GTIOCA);
        // 4. Type: MY_ETHER_TYPE(loopback)
        if (g_sw1_flag == true) {
            g_sw1_flag = false; // 플래그 내리기

            uint8_t speed_data = (uint8_t)duty_percent;
            cds_brightness = cds_data > 400 ? 1 : 0; // Dark=1, Bright=0

            can_id = 0x100;
            can_data[0] = speed_data;
            can_data[1] = cds_brightness;

            Send_CAN_Frame(can_id, 2, can_data);
        }

        if (g_sw2_flag == true) {
            g_sw2_flag = false; // 플래그 내리기

            if (g_ether_link_up) {

                memset(g_ether_tx_buffer, 0, 60);
                memset(&g_ether_tx_buffer[0], 0xFF, 6);
                memcpy(&g_ether_tx_buffer[6], myMac, 6);
                g_ether_tx_buffer[12] = (MY_ETHER_TYPE >> 8) & 0xFF;
                g_ether_tx_buffer[13] = (MY_ETHER_TYPE) & 0xFF;

                payload_len = (uint8_t)sprintf((char *)&g_ether_tx_buffer[14],
                                               "Raw Pot: %d mV | Raw CDS: %d\n", pot, cds);
                total_len = 14 + payload_len + 5;
                if (total_len < 60) total_len = 60;

                R_ETHER_Write(&g_ether0_ctrl, g_ether_tx_buffer, total_len);
            }
        }

        R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void CAN_CALLBACK(can_callback_args_t *p_args)
{
    if(p_args->event == CAN_EVENT_RX_COMPLETE)
    {

    }

}


void ether0_callback(ether_callback_args_t *p_args)
{
    /* 이더넷 케이블 연결 상태가 변하면 호출됨 */
    if (p_args->event == ETHER_EVENT_LINK_ON)
    {
        g_ether_link_up = true;
    }
    else if (p_args->event == ETHER_EVENT_LINK_OFF)
    {
        g_ether_link_up = false;
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
